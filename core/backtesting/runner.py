import os
from time import perf_counter
from concurrent.futures import ProcessPoolExecutor, as_completed
from typing import Iterable
from uuid import uuid4

import pandas as pd

from core.backtesting.results.metadata import BacktestMetadata
from core.backtesting.results.result import BacktestResult
from core.backtesting.results.store import ResultStore
from core.data_provider import CsvMarketDataCache
from core.data_provider.providers.default_provider import DefaultOhlcvDataProvider
from core.backtesting.backend_factory import create_backtest_backend

from core.backtesting.engine.backtester import Backtester

from core.backtesting.plotting.plot import TradePlotter

from core.backtesting.strategy_runner import run_strategy_single
from core.live_trading.strategy_loader import load_strategy_class
from core.reporting.runner import ReportRunner


class BacktestRunner:
    """
    Application-layer orchestrator.

    Responsibilities:
    - load market data
    - run strategies (single / multi symbol)
    - orchestrate backtest windows (FULL / OPT / VAL / FINAL)
    - aggregate RAW trades
    - run reporting & plotting

    Does NOT:
    - compute equity inside backtester
    - interpret results
    """

    def __init__(self, cfg):
        self.cfg = cfg

        self.provider = None

        # runtime strategy instances
        self.strategies = []          # all instantiated strategies
        self.strategy = None          # reference strategy (for reporting config)

        # data
        self.signals_df: pd.DataFrame | None = None
        self.trades_df: pd.DataFrame | None = None

    # ==================================================
    # 1Ô∏è‚É£ DATA LOADING
    # ==================================================

    def load_data(self) -> dict[str, pd.DataFrame]:
        t0 = perf_counter()
        print("‚è±Ô∏è load_data | start")

        backend = create_backtest_backend(self.cfg.BACKTEST_DATA_BACKEND)

        start = pd.Timestamp(self.cfg.TIMERANGE["start"], tz="UTC")
        end = pd.Timestamp(self.cfg.TIMERANGE["end"], tz="UTC")

        self.provider = DefaultOhlcvDataProvider(
            backend=backend,
            cache=CsvMarketDataCache(self.cfg.MARKET_DATA_PATH),
            backtest_start=start,
            backtest_end=end,
        )

        all_data: dict[str, pd.DataFrame] = {}

        for symbol in self.cfg.SYMBOLS:
            t_sym = perf_counter()

            df = self.provider.get_ohlcv(
                symbol=symbol,
                timeframe=self.cfg.TIMEFRAME,
                start=start,
                end=end,
            )

            print(
                f"‚è±Ô∏è load_data | get_ohlcv {symbol:<10} "
                f"{perf_counter() - t_sym:8.3f}s ({len(df)} rows)"
            )

            all_data[symbol] = df

        print(f"‚è±Ô∏è load_data | TOTAL {perf_counter() - t0:8.3f}s")
        return all_data

    # ==================================================
    # 2Ô∏è‚É£ STRATEGY EXECUTION
    # ==================================================

    def run_strategies(self, all_data: dict[str, pd.DataFrame]) -> pd.DataFrame:
        """
        Runs strategy logic and produces df_signals.
        """
        t0 = perf_counter()
        print(f"üìà STRATEGIES | start ({len(all_data)} symbols)")

        all_signals = []
        self.strategies = []
        self.strategy = None

        strategy_cls = load_strategy_class(self.cfg.STRATEGY_CLASS)

        # ---------- SINGLE SYMBOL ----------
        if len(all_data) == 1:
            symbol, df = next(iter(all_data.items()))

            df_signals, strategy = run_strategy_single(
                symbol=symbol,
                df=df,
                provider=self.provider,
                strategy_cls=strategy_cls,
                startup_candle_count=self.cfg.STARTUP_CANDLE_COUNT,
            )

            all_signals.append(df_signals)
            self.strategies.append(strategy)
            self.strategy = strategy

        # ---------- MULTI SYMBOL ----------
        else:
            with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:
                futures = [
                    executor.submit(
                        run_strategy_single,
                        symbol,
                        df,
                        self.provider,
                        strategy_cls,
                        self.cfg.STARTUP_CANDLE_COUNT,
                    )
                    for symbol, df in all_data.items()
                ]

                for future in as_completed(futures):
                    df_signals, strategy = future.result()

                    all_signals.append(df_signals)
                    self.strategies.append(strategy)

                    # pick reference strategy once
                    if self.strategy is None:
                        self.strategy = strategy

        if not all_signals:
            raise RuntimeError("No signals generated by strategies")

        self.signals_df = (
            pd.concat(all_signals)
            .sort_values(["time", "symbol"])
            .reset_index(drop=True)
        )

        print(f"üìà STRATEGIES | TOTAL {perf_counter() - t0:8.3f}s")
        return self.signals_df

    # ==================================================
    # 3Ô∏è‚É£ BACKTEST WINDOWS
    # ==================================================

    def _iter_windows(self) -> Iterable[tuple[str, pd.Timestamp, pd.Timestamp]]:
        """
        Yields (window_name, start, end)
        """
        if self.cfg.BACKTEST_MODE == "single":
            yield (
                "FULL",
                pd.Timestamp(self.cfg.TIMERANGE["start"], tz="UTC"),
                pd.Timestamp(self.cfg.TIMERANGE["end"], tz="UTC"),
            )
            return

        if self.cfg.BACKTEST_MODE == "split":
            for name, (start, end) in self.cfg.BACKTEST_WINDOWS.items():
                yield (
                    name,
                    pd.Timestamp(start, tz="UTC"),
                    pd.Timestamp(end, tz="UTC"),
                )
            return

        raise ValueError(f"Unknown BACKTEST_MODE: {self.cfg.BACKTEST_MODE}")

    def run_backtests(self) -> pd.DataFrame:
        """
        Runs backtests for:
        - each strategy instance
        - each symbol
        - each window

        Produces RAW trades dataframe.
        """
        if self.signals_df is None:
            raise RuntimeError("run_strategies must be called first")

        all_trades = []

        for window, start, end in self._iter_windows():
            print(f"üß™ BACKTEST WINDOW | {window} [{start} ‚Üí {end}]")

            df_window = self.signals_df[
                (self.signals_df["time"] >= start) &
                (self.signals_df["time"] <= end)
            ].copy()

            if df_window.empty:
                print(f"‚ö†Ô∏è No signals in window {window}")
                continue

            for strategy in self.strategies:
                symbol = strategy.symbol

                df_symbol = df_window[df_window["symbol"] == symbol]
                if df_symbol.empty:
                    continue

                backtester = Backtester(strategy=strategy)

                trades = backtester.run(
                    df_signals=df_symbol,
                    symbol=symbol,
                    window=window,
                    strategy_id=strategy.strategy_id
                    if hasattr(strategy, "strategy_id")
                    else type(strategy).__name__,
                    strategy_name=type(strategy).__name__,
                )

                if not trades.empty:
                    all_trades.append(trades)

        if not all_trades:
            raise RuntimeError("No trades after backtest")

        self.trades_df = (
            pd.concat(all_trades)
            .sort_values(["strategy_id", "symbol", "exit_time"])
            .reset_index(drop=True)
        )

        return self.trades_df

    def build_result(self) -> BacktestResult:
        """
        Build BacktestResult from current runner state.
        Must be called AFTER run_backtests().
        """

        if self.trades_df is None or self.trades_df.empty:
            raise RuntimeError("Cannot build result: no trades available")

        run_id = f"bt_{uuid4().hex[:8]}"

        metadata = BacktestMetadata.now(
            run_id=run_id,
            backtest_mode=self.cfg.BACKTEST_MODE,
            windows=(
                self.cfg.BACKTEST_WINDOWS
                if self.cfg.BACKTEST_MODE == "split"
                else None
            ),
            strategies=[s.get_strategy_id() for s in self.strategies],
            strategy_names={
                s.get_strategy_id(): s.get_strategy_name()
                for s in self.strategies
            },
            symbols=self.cfg.SYMBOLS,
            timeframe=self.cfg.TIMEFRAME,
            initial_balance=self.cfg.INITIAL_BALANCE,
            slippage=self.cfg.SLIPPAGE,
            max_risk_per_trade=self.cfg.MAX_RISK_PER_TRADE,
        )

        return BacktestResult(
            metadata=metadata,
            trades=self.trades_df,
        )

    # ==================================================
    # 4Ô∏è‚É£ REPORTING
    # ==================================================

    def run_report(self, result, run_path):
        ReportRunner(
            result=result,
            config=self.cfg,
            run_path=run_path,
            plot_context=self.strategy.df_plot,
        ).run()

    # ==================================================
    # 5Ô∏è‚É£ PLOTTING
    # ==================================================

    def plot_results(self):
        plots_dir = "results/plots"
        os.makedirs(plots_dir, exist_ok=True)

        for strategy in self.strategies:
            symbol = strategy.symbol

            trades = None
            if self.trades_df is not None:
                trades = self.trades_df[self.trades_df["symbol"] == symbol]
                if trades.empty:
                    trades = None

            plotter = TradePlotter(
                df=strategy.df_plot,
                trades=trades,
                bullish_zones=strategy.get_bullish_zones(),
                bearish_zones=strategy.get_bearish_zones(),
                extra_series=strategy.get_extra_values_to_plot(),
                bool_series=strategy.bool_series(),
                title=f"{symbol} chart",
            )

            plotter.plot()
            plotter.save(f"{plots_dir}/{symbol}.png")

    # ==================================================
    # 6Ô∏è‚É£ MAIN ENTRYPOINT
    # ==================================================

    def run(self):
        t0 = perf_counter()
        print("üöÄ BacktestRunner | start")

        # 1Ô∏è‚É£ DATA + STRATEGY
        all_data = self.load_data()
        self.run_strategies(all_data)

        if self.cfg.PLOT_ONLY:
            self.plot_results()
            print(f"üìä Plot-only finished TOTAL {perf_counter() - t0:.3f}s")
            return

        # 2Ô∏è‚É£ BACKTEST
        self.run_backtests()

        # 3Ô∏è‚É£ BUILD RESULT (SINGLE RESPONSIBILITY)
        result = self.build_result()

        # 4Ô∏è‚É£ SAVE RESULT (OFFLINE READY)
        store = ResultStore()
        run_path = store.save(result)

        # 5Ô∏è‚É£ REPORT (READ-ONLY CONSUMER)
        self.run_report(result, run_path)

        print(f"üèÅ Finished in {perf_counter() - t0:.2f}s")